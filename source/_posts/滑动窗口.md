---
title: 滑动窗口
date: 2022-10-08 19:38:46
tags: algorithm
---

### 滑动窗口

#### 要素是哪些？

> 目标窗口  need
>
> 实际窗口 window left right
>
> 匹配字符串数量 need.size()
>
> 目标字符串 start length

#### 关系是哪些？

> 一直往实际窗口里以right为索引扔字符
>
> 当字符是目标窗口的字符时更新匹配字符串数量
>
> 匹配字符数足够时缩小实际窗口

#### 例子

[s覆盖t的最小子串](https://leetcode.cn/problems/minimum-window-substring/)

[s中是否有t的排列](https://leetcode.cn/problems/permutation-in-string/)

[s中所有t的排列](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

[s中最长不重复子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

#### pyhton代码

```python
from collections import Counter


# s覆盖t的最小子串
class Solution(object):
    def findmincoverstr(self, s, t):
        need = dict(Counter(t))
        window = dict()
        start, length = 0, len(s)
        left, right = 0, 0
        valid = 0

        while right < len(s):
            char = s[right]
            if char in need:
                if char in window:
                    window[char] += 1
                else:
                    window[char] = 1
                if window[char] == need[char]:
                    valid += 1

            while valid == len(need):
                if right - left < length:
                    start = left
                    length = right - left

                deleteChar = s[left]
                if deleteChar in need:
                    if window[deleteChar] == need[deleteChar]:
                        valid -= 1
                    window[deleteChar] -= 1
                    # if window[deleteChar] == 0:
                    #     valid -= 1

                left += 1
            right += 1
        return s[start:start+length+1]

    # s中是否有t的排列
    def iscover(self, s, t):
        need = dict(Counter(t))
        window = dict()
        left, right = 0, 0
        valid = 0

        while right < len(s):
            char = s[right]
            if char in need:
                if char in window:
                    window[char] += 1
                else:
                    window[char] = 1
                if window[char] == need[char]:
                    valid += 1

            # if right - left == len(t):
            if right - left + 1 == len(t):
                if valid == len(need):
                    return True

                deleteChar = s[left]
                if deleteChar in need:
                    if window[deleteChar] == need[deleteChar]:
                        valid -= 1
                    window[deleteChar] -= 1
                left += 1
            right += 1

        return False

    # s中所有t的排列
    def getallcover(self, s, t):
        need = dict(Counter(t))
        window = dict()
        left, right = 0, 0
        valid = 0
        result = list()

        while right < len(s):
            char = s[right]
            if char in need:
                if char in window:
                    window[char] += 1
                else:
                    window[char] = 1
                if window[char] == need[char]:
                    valid += 1

            # if right - left == len(t):
            if right - left + 1 == len(t):
                if valid == len(need):
                    result.append(left)

                deleteChar = s[left]
                if deleteChar in need:
                    if window[deleteChar] == need[deleteChar]:
                        valid -= 1
                    window[deleteChar] -= 1
                left += 1
            right += 1

        return result

    # s中最长不重复子串
    def getlongestsubstring(self, s):
        window = dict()
        left, right = 0, 0
        result = -2**32

        while right < len(s):
            char = s[right]
            if char not in window:
                window[char] = 1
            else:
                window[char] += 1

            if window[char] > 1:
                deletechar = s[left]
                window[deletechar] -= 1
                left += 1
            result = max(result, right - left + 1)
            right += 1
        return result



if __name__ == "__main__":
    s = Solution()
    # ss = "ADOBECODEBANC"
    # ss = "cbaebabacd"
    ss = "abcdefghijkllll"
    t = "abc"
    print(s.getlongestsubstring(ss))


```

#### 二、三题两个非常值得注意的地方

##### 缩减窗口为什么可以用if

> 因为针对字符序列s，是对其进行枚举，等价于while了。

##### 为什么缩减窗口的时候要+1

> ```python
>             if right - left + 1 == len(t):
> ```
>
> 从个数讨论：对于两个索引a、b，b-a代表b+1到b的个数
>
> 从数量讨论：b-a代表的是a到b之间的长度
>
> 而这里代表的是个数，+1代表的是加上a本身这个数的量
>
> 举个例子：s=”acb； t=“ab”； b-a=2，实际上a-b是三个数， 所以加1
>
>


