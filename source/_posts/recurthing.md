---
title: 递归的有趣地方
date: 2022-09-02 19:06:37
tags:
---

### 递归是什么

> 起于迭代，不止迭代。
#### 例子1
> 从前有座山，山上有座庙，庙里有个老和尚，老和尚在和小和尚说故事，故事是什么
> 从前有座山，山上有座庙...
> 这是递归的一个实例吗？再加上一个条件：有另外一个小和尚在敲木鱼，敲到100下
> 老和尚就睡着了。

#### 例子2
> 你在10条泳道里游泳。
> 最开始你在泳道1游泳，当游到递归处时：
> 你进入了泳道2的起始点，当游到泳道2的递归处时：
> 同样的，你进入泳道3的起始点...
> 你现在在泳道10的递归出了，但是此处递归是continue，
> 你游到了泳道10的终点，接下来：
> 你到了泳道9进入泳道10的递归处，现在你继续游泳道9的尽头，
> 同样的，直到泳道1的尽头，你此次递归结束。


### 递归有趣的地方在哪
> 在：处理事情在进入下一个递归之前还是之后。
> 已经对数据结构有图式的直接用树即可。
> 例子： 游玩故宫的例子，从大门游览到终点乾清宫，乾清宫这有个人给你一封信。
>        你再拿着这封信挨个游玩过的景点回去直到大门处结束。
```python
def recur(route):
    // 到达乾清宫收到一封神秘的信
    if arriveQianqinggong:
        return message
    
    // 做事1
    message = self.recur(route.next)
    // 做事2

```
> 在1处就是在去乾清宫的路上，做的事情只能用前面景点看到的东西，
> 在2处是在从乾清宫回大门的路上了，此时你身上有一封信，这儿能做
>      的事情也比较多，可以用来自乾清宫的信息和返途中看到的信息。
>      举个例子，你可以读到信的内容和在信上盖个章。

### 举个🌰
[树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
```python
def getMaxDepthOfTree(root):
    // 到了乾清宫，拿到信了
    if not root:
        return 0

    // 去下一个景点
    numberLeft = self.getMaxDepthOfTree(root.left)
    numberRight = self.getMaxDepthOfTree(root.right)
    
    // 拿到信的回途，挨个景点给盖个章
    return max(numberLeft, numberRight) + 1
```
> 举个形象的例子就是这个样子。顺便就想起来想说递归的另外一个值得说的点，如果迭代是一次访问，
> 那么递归其实可以说是相当于有两次访问的，二次访问就是清除记录在栈中的信息时，正是有着这种特征
> 使得它很有趣。比如逆序输出链表：
```python
def recur(head):
    if not head:
        return 

    self.recur(head.next)
    print(heda.val)
```

>  如果在树这种数据结构中上述就是前序、后序遍历。
>  但是这也只是我想说的一个实例，递归不止于这里。
>  对于树中凡是需要子树来提供信息的都逃不开在
>  递归后做事，也就是后序遍历。




